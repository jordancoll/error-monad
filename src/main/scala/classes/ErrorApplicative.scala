package classes 

trait ErrorApplicative[F[_, _]] extends ErrorSemigroupal[F] with ErrorFunctor[F] {

  def pure[E, A](a: A): F[E, A]

  def [EA, EB, A, B](fa: F[EA, A]) ap(ff: F[EB, A => B]): F[EA | EB, B]

  override def [E, A, B](fa: F[E, A]) map(f: A => B): F[E, B] = {
    fa.ap(pure(f))
  }

  override def [EA, EB, A, B](fa: F[EA, A]) product(fb: F[EB, B]): F[EA | EB, (A, B)] = {
    val ff: F[EA, B => (A, B)] = map(fa) { a =>
      { b => (a, b) }
    }
    fb.ap(ff)
  }

  // these methods should be autogenerated
  def [E1, E2, E3, A1, A2, A3, R](t: (F[E1, A1], F[E2, A2], F[E3, A3]))
      mapN(f: (A1, A2, A3) => R): F[E1 | E2 | E3, R] = {
    
    val f12: F[E1 | E2, (A1, A2)] = product(t._1)(t._2)

    val f123: F[E1 | E2 | E3, ((A1, A2), A3)] = product(f12)(t._3)
    
    map(f123) { case ((a1, a2), a3) => f(a1, a2, a3) }
  }
}
