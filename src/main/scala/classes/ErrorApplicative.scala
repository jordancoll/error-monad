package classes 

trait ErrorApplicative[F[_, _]] extends ErrorSemigroupal[F] with ErrorFunctor[F]:

  def pure[E, A](a: A): F[E, A]

  extension [EA, A](fa: F[EA, A])
    def ap[EB, B](ff: F[EB, A => B]): F[EA | EB, B]

    override def product[EB, B](fb: F[EB, B]): F[EA | EB, (A, B)] =
      val ff: F[EA, B => (A, B)] = fa.map { a => (a, _) }
      fb.ap(ff)

  extension [E, A](fa: F[E, A])
    override def map[B](f: A => B): F[E, B] = fa.ap(pure(f))

  // these methods should be autogenerated
  extension [E1, E2, E3, A1, A2, A3, R](t: (F[E1, A1], F[E2, A2], F[E3, A3]))
    def mapN(f: (A1, A2, A3) => R): F[E1 | E2 | E3, R] = {
      (t._1 product t._2 product t._3).map {
        case ((a1, a2), a3) => f(a1, a2, a3)
      }
    }
